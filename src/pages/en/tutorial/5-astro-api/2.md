---
layout: ~/layouts/TutorialLayout.astro
title: Generating pages dynamically
setup: |
  import Checklist from '~/components/Checklist.astro';
  import Goals from '~/components/tutorial/Goals.astro';
  import MultipleChoice from '~/components/tutorial/MultipleChoice.astro';
  import Option from '~/components/tutorial/Option.astro';
---

<Goals>
  - generated multiple page routes dynamically from a single Astro component
  - identified the dynamic route paramater using `[bracket]` notation
  - specified which pages to be built, and passed them each props using `getStaticPaths()`
</Goals>

## Dynamic Page Routing

Adding `.astro` and `.md` files within `src/pages/` creates a new **static** page on your website. You can also create entire sets of pages dynamically using `.astro` files that export `getStaticPaths()`. This function returns an array of page routes, and all of the pages at those routes will use the same template defined in the file.

## Create Pages Dynamically

1. Create a new file at `src/pages/tags/[tag]`. (You will have to create a new folder.) Notice that the file name (`[tag].astro`) uses square brackets. Paste the following code into the file:

    ```astro title="src/pages/posts/tags/[tag].astro"
    ---
    import BaseLayout from '../../layouts/BaseLayout.astro';

    export async function getStaticPaths({ }) {
      return[
        {params: {tag: "astro"}},
        {params: {tag: "sucesses"}},
        {params: {tag: "community"}},
        {params: {tag: "learning in public"}}
      ]
    }

    const { tag } = Astro.params
    let title = tag; 
    ---
    <BaseLayout title={title}>
      <p>Posts tagged with {title}</p>    
    </BaseLayout>
    ```

2. Visit `localhost:3000/tags/astro` in your browser preview and you should see a page, generated dynamically from `[tag].astro`. Check that you also have pages created at `/tags/successes`, `/tags/community`, and `/tags/learning%20in%20public`. 


## Using props in dynamic routes

1. Add following props to your `getStaticPaths()` function in order to make data from all your blog posts available to each page route.

    Be sure to give each route in your array the new props, and then make those props available to your component template outside of your function.

    ```astro title="src/pages/posts/tags/[tag].astro" ins={5,17} "props: {posts: allPosts}" 
    ---
    import BaseLayout from '../../layouts/BaseLayout.astro';

    export async function getStaticPaths({ }) {
      const allPosts = await Astro.glob('../posts/*.md');

      return [
        {params: {tag: "astro"}, props: {posts: allPosts}},
        {params: {tag: "sucesses"}, props: {posts: allPosts}},
        {params: {tag: "community"}, props: {posts: allPosts}},
        {params: {tag: "blogging"}, props: {posts: allPosts}},
        {params: {tag: "setbacks"}, props: {posts: allPosts}},
        {params: {tag: "learning in public"}, props: {posts: allPosts}}
      ]
    }

    const { posts } = Astro.props
    const { tag } = Astro.params
    let title = tag;
    ```

2. Filter your list of posts to only include posts that contain the page's own tag.

    ```astro title="/src/pages/posts/tags/[tag]" ins={4}
    ---
    const { posts } = Astro.props
    const { tag } = Astro.params
    const filteredPosts = posts.filter((post) => post.frontmatter.tags.includes(tag));

    let title = tag;
    ---
    ```

  Now you can update your HTML template to include information from each blog post. 

3. To list your posts on each of these new dynamically-generated tag pages, add the following code to the template of `[tag].astro`:

    ```astro title="src/pages/posts/tags/[tag].astro" ins={3-5}
    <BaseLayout title={title}>   
      <p>Posts tagged with {title}</p>
      <ul>
        {filteredPosts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
      </ul>
    </BaseLayout>
    ```

4. You can even refactor this to use your `<BlogPost />` component instead! (Don't forget to import this component at the top of `[tag].astro`.)

    ```astro title="src/pages/posts/tags/[tag].astro" del={4} ins={5}
    <BaseLayout title={title}>
      <p>Posts tagged with {title}</p>
      <ul>
        {filteredPosts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}        
        {filteredPosts.map(post => <BlogPost url={post.url} title={post.frontmatter.title}/>)}
      </ul>
    </BaseLayout>
    ```

5. Check your browser preview for your individual tag pages, and you should now see a list of all of your blog posts containing that particular tag.

## Analyze the pattern

For each of the following, state whether the code is written **inside** the `getStaticPath()` function, or **outside** of it, in your component script.

1. The `Astro.glob()` call to receive information about all your `.md` files to pass to each page route.

    <MultipleChoice>
    <Option isCorrect>inside `getStaticPaths`</Option>
    <Option>outside `getStaticPaths`</Option>
    </MultipleChoice>

2. The list of routes to be generated (returned) by `getStaticPaths()`

    <MultipleChoice>
    <Option isCorrect>inside `getStaticPaths`</Option>
    <Option>outside `getStaticPaths`</Option>
    </MultipleChoice>

3. Definitions of `props` and `params` values to be used by each individual page in the component template.

    <MultipleChoice>
    <Option>inside `getStaticPaths`</Option>
    <Option isCorrect>outside `getStaticPaths`</Option>
    </MultipleChoice>

:::note[Takeaway]
To **give** information to your function to construct a page route, write it **inside** `getStaticPaths()`.

To **use** information in the HTML template of a page route, write it **outside** `getStaticPaths()`.
:::


## Advanced JavaScript: Automatically generate pages from existing tags

Your tag pages are now defined statically in `[tag].astro`. If you add a new tag to a blog post, you will also have to revisit this page and update your page routes.

The following example shows how to replace your code on this page with code that will automatically look for, and generate pages for, each tag used on your blog pages.

:::note
Even if it looks challenging, you can try following along with the steps to build this function yourself! If you don't want to walk through the JavaScript required right now, you can skip ahead to the [finished version of the code](#final-code-sample) and use it directly in your project, replacing the existing content.
:::

Let's start by planning out the steps.

Replace your existing `getStaticPaths()` with the following **pseudocode** (a description in words of what you would _like_ your code to do, but not the actual code to execute it) in your `getStaticPaths()` function:

```astro title="src/pages/posts/tags/[tag].astro"
---
export async function getStaticPaths() {
  // 1. Retrieve data from all Markdown posts.
 
  // 2. Create a new `Set` for holding all the tags used on the blog.
  
  // 3. Loop through all the Markdown files, and add any tags found to the Set of tags.

  // 4. Turn your Set of tags into an array you can map through.

  // 5. For each tag in the array, filter your blog posts to find only the ones that include it 
  //    Then, return 
  //    - the name of the tag (for defining the parameters your page routes)
  //    - an array of posts that include the tag (to be passed as props to each page).
}
---
```
You will tackle each piece individually. Some of the steps you have already seen!

### Constructing `getStaticPaths()`

We have five tasks written in pseudocode to turn into code. Some will be shorter, and some will be longer.  Some of them you will be familiar with, but some of them might be new to you. That's OK! By the end, you'll have working code that you can inspect further if you need to.

Remember, each of these sections of code will be written _inside_ your `getStaticPaths()` function, in the order they appear.

### 1. Retrieve data from all Markdown posts

This should look familiar! You have written this line of code before:

```js title="src/pages/posts/tags/[tag].astro"
  // 1. Retrieve data from all Markdown posts.
  const allPosts = await Astro.glob('../pages/posts/*.md');
```

### 2. Create a `Set` that will hold your tags

A `Set` is a JavaScript object that is a collection of unique items. It is similar to an array, but it igores repeated values. Some of your blog posts may have the same tags (e.g. "learning in public"). But, you want to be able to list all the unique tags, only once each. 

```js title="src/pages/posts/tags/[tag].astro"
  // 2. Create a new `Set` for holding all the tags used on the blog.
  const allTags = new Set();
```

### 3. Add each postâ€™s tags to your new `Set`

Because a `Set` ignores repeated values, you can add safely add every tag from every post to it. For each post, you will go one by one through each of its tags, adding every tag you encounter to your new set. Notice that you are looping within a loop!

```js title="src/pages/posts/tags/[tag].astro"
  // 3. Loop through all the Markdown files, and add any tags found to the Set of tags.
  allPosts.forEach((post) => {
    post.frontmatter.tags.forEach((tag) => allTags.add(tag));
  });
```

You now have a Set `allTags` with element items `"astro"`, `"successes"`, `"community"`, `"blogging"`, `"setbacks"`, `"learning in public"` 

### 4. Convert your `Set` of unique tags into an array

You used a `Set` in the previous steps to make sure you didn't have any duplicated values. But, an array is useful for mapping through and using those items.

```js title="src/pages/posts/tags/[tag].astro"
  // 4. Turn your Set of tags into an array you can map through.
  let uniqueTags = Array.from(allTags);
```

You now have an array `uniqueTags` with element items `"astro"`, `"successes"`, `"community"`, `"blogging"`, `"setbacks"`, `"learning in public"` 

### 5. Define the `return` value of the `getStaticPaths` function

A `getStaticPaths` function should always return a list of objects containing `params` (what you should call each page route) and optionally any `props` (data that you want passed to those pages). This is exactly what you did earlier in this lesson, defining each tag name that you knew was used in your blog and passing the entire list of posts as props to each page.

We still want each tag name to become a page on your website. But now, instead of listing out individually each page route to be built, you will generate this list of tags automatically from your `uniqueTags` array. This means, you don't have to know ahead of time which tags are used on your site. And, you can add new posts with new tags and not update any code. The JavaScript above will automatically find all your tags!

And, you really want each of those page routes to "know about" only the blog posts that include that tag. So you will also filter the list of all blog posts before sending to each page as props.

Replace the final section of pseudocode with the code below:

```js title="src/pages/posts/tags/[tag].astro"
  // 5. For each tag, filter for the blog posts that include it, then return
  //    the name of the tag (for defining the parameters your page route)
  //    an array of posts that include the tag (to be passed as props).
  return uniqueTags.map((tag) => {
    const taggedPosts = allPosts.filter((post) => post.frontmatter.tags.includes(tag));
    return {
      params: { tag },
      props: { posts: taggedPosts },
    };
  });
```

## Final code sample

To check your work, or if you just want complete, correct code to copy into `[tag].astro`, here is what your Astro component should look like:

```astro title="src/pages/posts/tags/[tag].astro"
---
import BaseLayout from '../../layouts/BaseLayout.astro';
import BlogPost from '../../components/BlogPost.astro'

export async function getStaticPaths() {
  const allPosts = await Astro.glob('../posts/*.md');
  const allTags = new Set();
  
  allPosts.forEach((post) => {
    post.frontmatter.tags.forEach((tag) => allTags.add(tag));
  });
  
  const uniqueTags = Array.from(allTags);

  return uniqueTags.map((tag) => {
    const taggedPosts = allPosts.filter((post) => post.frontmatter.tags.includes(tag));
    return {
      params: { tag },
      props: { posts: taggedPosts },
    };
  });
}

const { posts } = Astro.props;
const { tag } = Astro.params;

let title = tag; 
---
<BaseLayout title={title}>
  <p>Posts tagged with {title}</p>
  <ul>
    {posts.map((post) => <BlogPost url={post.url} title={post.frontmatter.title}/>)}
  </ul>
</BaseLayout>
```

Now, you should be able to visit any of your tag pages in your browser preview! 

Navigate to `localhost:3000/tags/community` and you should see a list of only your blog posts with the tag `community`. Similarly `localhost:3000/tags/learn%20in%20public` should display a list of the blog posts tagged `learning in public`.

In the next section, you will use `Astro.glob()` again to build a static page that will show a list of every tag, with each one each linking to its own individual page.

## Before you go

### Test your knowledge

Choose the term that matches the description.

1. A function that returns an array of page routes.

    <MultipleChoice>
      <Option>parameter</Option>
      <Option>dynamic routing</Option>
      <Option isCorrect>`getStaticPaths()`</Option>
      <Option>props</Option>
    </MultipleChoice>

2. The process of creating multiple page routes from one function in Astro.

    <MultipleChoice>
      <Option>parameter</Option>
      <Option isCorrect>dynamic routing</Option>
      <Option>`getStaticPaths()`</Option>
      <Option>props</Option>
    </MultipleChoice>

4. A value that defines the name of a page route generated dynamically.

    <MultipleChoice>
      <Option isCorrect>parameter</Option>
      <Option>dynamic routing</Option>
      <Option>`getStaticPaths()`</Option>
      <Option>props</Option>
    </MultipleChoice>

### Checklist for moving on

<Checklist key="parameter">
- [ ] I can generate pages dynamically, using one `[parameter].astro` file to generate several pages on my site.
- [ ] I can pass `props` to each page route, and use these props in the common page template.
- [ ] I can plan my steps in pseudocode, creating a roadmap for future work.
</Checklist>

### Resources

- [Dynamic Page Routing in Astro](/en/core-concepts/routing/#dynamic-routes)

- [`getStaticPaths()` API documentation](/en/reference/api-reference/#getstaticpaths)
